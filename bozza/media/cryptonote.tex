\section{Inizio dello sviluppo e storia
dell'algoritmo}\label{inizio-dello-sviluppo-e-storia-dellalgoritmo}

Dato che Bitcoin fallisce dal punto di vista della privacy delle
transazioni e della resistenza agli ASICs (\emph{Application Specific
Integrated Circuits}), lo sviluppatore \textbf{Nicolas van Saberhagen},
che molti pensano essere un nome di fantasia, con alcune speculazioni
che lo associerebbero al fantomatico creatore di Bitcoin,
\textbf{Satoshi Nakamoto}, nel 12 dicembre 2012 presenta un documento
con all'interno l'idea di \textbf{CryptoNote}.

Questo innovativo protocollo di consenso viene presentato come una
fattibile alternativa ai meccanismi tradizionali utilizzati dalle
criptomonete, come la \emph{Proof-Of-Work} di Bitcoin (la prova che sei
in grado di eseguire un lavoro), oltretutto in grado di garantire
elevati livelli di anonimato e un opportuna resistenza agli ASICs.
Alcune delle funzioni menzionate riguardavano transazioni di dimensione
inferiore e non facilmente associabili ad un utente, l'utilizzo delle
firme ad anello volte a migliorare la sicurezza e respingere gli
attacchi alla blockchain e l'adattamento dinamico della emissione di
moneta.

\subsection{Sviluppo dello standard CryptoNight e
adozione}\label{sviluppo-dello-standard-cryptonight-e-adozione}

Qualche mese dopo, gli sviluppatori Seigen, Max Jameson, Tuomo Nieminen,
Neocortex e Antonio M. Juarez, pubblicano un documento, facente parte
degli standard di CryptoNote, con all'interno la descrizione della
funzione di hash per la proof-of-work di CryptoNote, chiamata
\textbf{CryptoNight}.

\textbf{Bytecoin (BCN)} è stata la prima criptomoneta ad adottare il
protocollo di consenso CryptoNote, scelta giustificata dalla volontà dei
fondatori di avere una criptomoneta volta alla privacy finanziaria,
attraverso una protezione completa dell'utente che utilizza gli
strumenti finanziari messi a disposizione, dalle transazioni
all'identità personale. Come altre differenze, abbiamo l'aggiustamento
della difficoltà di minare nuova moneta ad ogni blocco, generando un
blocco ogni due minuti circa. Nonostante le buone premesse, la moneta
oggi ha un \emph{market cap} irrisorio e non è stata adottata a causa di
svariati problemi: - Inizialmente, la moneta è stata pre-minata,
fornendo l'80\% delle monete ad un gruppo di \emph{early adopters},
generando una distribuzione iniqua e sleale - Bytecoin ha avuto vari
problemi tecnici di instabilità nel corso della sua vita, con difficoltà
da parte degli utenti che partecipavano alla rete impossibilitati a
sincronizzare tutta la blockchain. - Il 20 dicembre 2017, la rete di
Bytecoin ha ricevuto un attacco DDoS massiccio, con lo scopo di rubare
le monete e distribuire la potenza tra le varie monete che adottano lo
standard CryptoNote. Gli utenti affetti erano soprattutto chi aveva un
software non aggiornato per minare nuova moneta e chi utilizzava
\emph{desktop wallets} e \emph{web wallets} si è visto rallentare o
disabilitare la sincronizzazione dei pagamenti, cosa che ha aumentato lo
sconforto dei suoi partecipanti alla rete - Non si hanno notizie
riguardo futuri sviluppi della moneta, con l'ultimo post che prometteva
lo sviluppo di una tecnologia per nascondere gli importi delle
transazioni e di creare un wallet più efficiente e sicuro, risalente al
2019.

\hfill\break
Un'altra moneta, chiamata \textbf{Monero (XMR)}, nel aprile 2014 adottò
CryptoNote, scelto per garantire la privacy e la decentralizzazione del
mining. La decisione di utilizzare questa tecnologia è stata una dei
fattori che hanno contibuito alla crescita della reputazione e al
successo di Monero come una delle monete digitali più promettenti e
utilizzate. Monero ha avuto un ruolo cruciale nello sviluppo attivo di
CryptoNight, introducendo varie modifiche al fine di adattare la
funzione alle proprie necessità. Alcune versioni utilizzate erano
specifiche per miners con risorse limitate per il mining, altre sono
state rilasciate per ottimizzare l'efficienza e l'equità del mining,
oltre a mantenere la resistenza agli ASIC. Nonostante ciò, nel 2019
Monero decise di cambiare il suo algoritmo da CryptoNote a RandomX, di
cui forniremo una descrizione data l'affinità e i prinicipi che ne
dominano lo sviluppo, oltre che risolvere una serie di problemi che si
erano sviluppati nell'algoritmo di CryptoNight.

Di seguito forniremo una panoramica sulla tecnologia CryptoNote,
presentando un approccio dettagliato e analitico per comprenderne non
solo gli aspetti funzionali e tecnici dell'algoritmo ma anche le
intrinseche necessità di migliorare lo stato corrente degli algoritmi
\emph{Proof-Of-Work}, incrementando privacy e anonimato.

\section{Aspetti tecnici di
CryptoNote}\label{aspetti-tecnici-di-cryptonote}

\subsection{Privacy e Anonimato nel Cash
Elettronico}\label{privacy-e-anonimato-nel-cash-elettronico}

Privacy e anonimato sono aspetti fondamentali del cash elettronico. I
pagamenti peer-to-peer mirano a rimanere nascosti agli occhi di terze
parti, una netta differenza rispetto alle banche tradizionali. In
generale le aziende non vogliono rivelare le loro transizioni interne e
le persone comuni desiderano mantenere riservate le proprie spese
personali.

\subsection{Proprietà di Irretracciabilità e Non
Collegabilità}\label{proprieta-di-irretracciabilita-e-non-collegabilita}

T. Okamoto e K. Ohta hanno descritto sei criteri per un sistema di
denaro elettronico ideale, uno dei quali riguarda la privacy: la
relazione tra l'utente e i suoi acquisti deve essere irrintracciabile
{[}1\^{}{]}. Dunque, per definire il concetto di sistema di pagamento
anonimo servono due proprietà:

\begin{itemize}
\item
  Irretracciabilità: per ogni transizione eseguita tutti i possibili
  mittenti devono avere la stessa probabilità di essere identificati.
\item
  Non collegabilità: per due qualsiasi transizioni in uscita deve essere
  impossibile dimostrare che siano state inviate dalla stessa persona
\end{itemize}

\subsection{Limiti di Bitcoin}\label{limiti-di-bitcoin}

Bitcoin non soddisfa però il primo criterio, dato che tutte le
transazioni che avvengono sono pubbliche e possono essere ricondotte a
un\textquotesingle unica origine e ad un unico destinatario.\\
Anche se due partecipanti effettuano transazioni in modo indiretto, un
metodo di ricerca del percorso ben progettato (ad esempio, l'algoritmo
``A star'' {[}2\^{}{]}) può rivelare l'origine e il destinatario
finale.\\
Inoltre Bitcoin non sembra soddisfare neanche la seconda proprietà,
infatti, da un attenta analisi della blockchain e da alcune ricerche
{[}3\^{}{]}, {[}4\^{}{]}, {[}5\^{}{]}, si potrebbe rilevare una
connessione tra gli utenti e le loro transazioni.\\
L'incapacità di Bitcoin di soddisfare queste due proprietà ci porta a
concludere che esso non rappresenta un sistema anonimo, ma piuttosto
pseudo-anonimo. Sono state proposte diverse soluzioni {[}6\^{}{]},
{[}7\^{}{]} basate sull'idea di mescolare diverse transazioni pubbliche
e inviarle tramite un indirizzo intermediario ma questo porterebbe un
altro inconveniente, ovvero una terza parte fidata.

\subsection{Problemi del Protocollo di Consenso di
Bitcoin}\label{problemi-del-protocollo-di-consenso-di-bitcoin}

Il creatore di Bitcoin, Satoshi Nakamoto, ha descritto il protocollo di
consenso come ``un processore, un voto'', utilizzando SHA-256 per il
meccanismo di proof-of-work. Poiché gli utenti votano per determinare
l'ordine unico della cronologia delle transazioni, la correttezza e la
coerenza di questo processo sono condizioni fondamentali per l'intero
sistema. Ci sono due aspetti da sottolineare: - La rete è fuori pericolo
se il 51\% del potere di mining è sotto il controllo di utenti onesti. -
Il progresso del sistema è limitato perché se si vuole cambiare la
versione del protocollo il cambiamento avverrà solo se supportato dalla
stragrande maggioranza degli utenti {[}8\^{}{]}.

Questo permette di delineare le proprietà che una funzione di
proof-of-work deve soddisfare: non deve consentire ad un partecipante
della rete di ottenere un vantaggio significativo rispetto ad un altro,
è necesaria una sorta di equivalenza tra hardware comune e dispositivi
costisi. SHA-256 non ha queste caratteristiche: una GPU è più efficacie
di una CPU e i dispositivi ASIC sono più potenti delle GPUs
{[}9\^{}{]}.\\
Bitcoin crea quindi delle condizioni favorevoli per un ampio divario nel
potere di voto tra partecipanti, violando il principio di ``un
processore, un voto'' : i proprietari di GPU e ASIC hanno infatti molto
più potere di voto rispetto a coloro che utilizzano solo CPU.\\
\strut \\
Il sistema di script in Bitcoin è troppo complicato e pesante.
Potenzialmente consente di creare transazioni sofisticate, ma alcune
delle sue funzionalità sono disabilitate per motivi di
sicurezza{[}10\^{}{]} {[}11\^{}{]}.

\subsection{Protocolli di Firma e schemi di
CryptoNote}\label{protocolli-di-firma-e-schemi-di-cryptonote}

Seguono ora degli schemi di transazioni completamente anonime che
soddisfano le condizioni di non irretracciabilità e non collegabilità.
Una caratteristica importante è l'autonomia: il mittente non è tenuto a
collaborare con altri utenti o terze parti per le transazioni.

Lo schema di CryptoNote si basa su una primitiva crittografica chiamata
\emph{group signature}, inventata da \emph{D. Chaun} e \emph{E. van
Heyst} {[}12\^{}{]} che consente di firmare un messaggio per conto di un
gruppo.\\
Dopo aver firmato, l'utente fornisce (per verificare) non la propria
chiave pubblica, ma le chiavi di tutti gli utenti del suo gruppo. Chi
verifica vede che il vero firmatario è un membro di questo gruppo, ma
non conosce la sua esatta identità.\\
Il protocollo originale prevedeva una Terza Parte Fiduciosa (Gestore del
Gruppo), ed era l'unico che poteva risalire al reale firmatario. La
versione successiva, \emph{ring} \emph{signature}, introdotta da Rivest
{[}13\^{}{]} , prevedeva uno schema ad anello autonomo senza
responsabile del gruppo e con revoca dell'anonimato.\\
Successivamente, sono apparse diverse modifiche, quella che viene
adottata su CryptoNote per larga parte si basa sullo studio
\emph{Traceable ring signature} di E. Fujisaki and K. Suzuki
{[}14\^{}{]}.\\
Per distinguere l\textquotesingle algoritmo originale da quello
modificato nella versione su CryptoNote, quest\textquotesingle ultima
firma verrà chiamata \emph{one-time ring signature}, sottolineando la
capacità dell\textquotesingle utente di produrre una sola firma valida
con la chiave privata.\\
La proprietà di tracciabilità è stata indebolita, mantenendo però quella
di collegabilità (linkability) per fornire unicità: la chiave pubblica
potrebbe comparire in molti set di verifica esterni e la chiave privata
può essere utilizzata per generare una firma anonima unica. Nel caso di
un tentativo di doppia spesa, queste due firme saranno collegate, ma non
è necessario rivelare l'identità del firmatario.

Alla base dell'algoritmo di firma si usa EdDSA, sviluppato e
implementato da \emph{D.J. Bernstein} {[}15\^{}{]}, parametri comuni di
dominio sono: - q: numero primo; - d: elemento of Fq; - E: equazione
della curva ellittica; - G: punto base; - l: ordine primo del punto
base; - Hs: funzione hash crittografica \{0, 1\} * → Fq; - Hp: funzione
hash deterministica E(Fq) → E(Fq).

Al fine di ottenere una maggiore privacy, sono necessari alcuni nuovi
termini che non dovrebbero essere confusi con le entità di Bitcoin:

\begin{itemize}
  \item
    \textbf{private ec-key} è una chiave segreta standard di curva
    ellittica: un numero $a \in [1,l-1]$
  \item
    \textbf{public ec-key} è una chiave pubblica standard di curva
    ellittica: un punto $A=aG$;
  \item
    \textbf{one-time keypair} è una coppia di chiavi ec-private e
    ec-public;
  \item
    \textbf{private user key} è una coppia \emph{$(a, b)$} di due diverse
    chiavi ec-private;
  \item
    \textbf{tracking key} è una coppia \emph{$(a, B)$} di chiave ec-private
    e chiave ec-public \emph{(dove $B=bG$ e $a \neq b$)};
  \item
    \textbf{public user key} è una coppia \emph{$(A, B)$} di due chiavi
    ec-public derivate da \emph{$(a, b)$};
  \item
    \textbf{standard} \textbf{address} è una rappresentazione di una
    chiave utente pubblica mediante una stringa digitabile
    dall\textquotesingle utente con correzione degli errori.
  \end{itemize}

La struttura generale della transazione rimane quasi identica a quella
di Bitcoin: ogni utente può scegliere diversi pagamenti (transaction
outputs), firmarli con le chiavi private corrispondenti e inviarli a
diverse destinazioni.\\
Contrariamente al modello di Bitcoin, in cui un utente possiede sia le
chiavi uniche private che pubbliche, nel modello proposto un mittente
genera una chiave one-time publica basata sull'indirizzo del
destinatario e su alcuni dati. In questo senso, una transazione in
entrata per lo stesso destinatario viene inviata a una chiave pubblica
monouso (non direttamente a un indirizzo univoco) e solo il destinatario
può recuperare la parte privata corrispondente per riscattare i suoi
fondi (utilizzando la sua chiave privata unica). Il destinatario può
spendere usando una firma ad anello, mantenendo anonima la sua proprietà
e la sua effettiva spesa.

\subsection{Funzionamento delle
transazioni}\label{funzionamento-delle-transazioni}

Gli indirizzi Bitcoin classici, una volta pubblicati, diventano
identificatori inequivocabili per ogni pagamento in entrata,
collegandoli tra loro e associandoli al destinatario.

\includegraphics{image6.png}

Viene proposta una soluzione che consente all\textquotesingle utente di
pubblicare un singolo indirizzo e ricevere pagamenti incondizionati non
collegabili. La destinazione di ciascun output (di default) è una chiave
pubblica unica, derivata dall\textquotesingle indirizzo del destinatario
e dall\textquotesingle iniezione di dati casuali da parte del
mittente.\\

\includegraphics{image7.png}

Innanzitutto, il mittente esegue il protocollo di scambio Diffie-Hellman
per ottenere un segreto condiviso dai suoi dati e da una metà
dell\textquotesingle indirizzo. Successivamente calcola una chiave di
destinazione monouso, utilizzando questi segreti e la seconda metà. Per
questi due passaggi sono necessarie due chiavi ec-keys del destinatario;
quindi, un indirizzo CryptoNote standard è grande quasi il doppio di un
indirizzo Bitcoin. Il destinatario esegue anche il protocollo
Diffie-Hellman e poi recupera la chiave segreta corrispondente.

Una transazione standard procede come segue:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Alice vuole inviare un pagamento a Bob, che ha pubblicato il suo
  indirizzo. Lo decomprime e ottiene la chiave utente pubblica di Bob
  \emph{$(A, B)$}.
\item
  Alice genera un numero casuale $r \in [1,l-1]$ e calcola la chiave
  pubblica one-time $P=H_s(rA)G+B$.
\item
  Alice usa $P$ come chiave di destinazione per l\textquotesingle output e
  inserisce anche il valore $R=rG$ (come parte del protocollo
  Diffie-Hellman) da qualche parte nella transazione. Alice può creare
  altri output con chiavi pubbliche uniche: chiavi diverse dei
  destinatari \emph{$(A_i,B_i)$} implicano $P_i$ diversi anche con
  lo stesso $r$.

  \includegraphics{image3.png}
\item
  Bob controlla ogni transazione in arrivo con la sua chiave privata $(a,
  b)$, calcolando $P'=H_s(aR)G+B$. Se la transazione di Alice è presente,
  allora $aR=arG=rA$ e $P'=P$.
\item
  Ora Bob può recuperare la chiave privata una tantum corrispondente:
  $x=H_s(aR)+b$, così come $P=xG$. Può spendere questo output in qualsiasi
  momento firmando la transazione con $x$.

  \includegraphics{image4.png}
\end{enumerate}

Di conseguenza, Bob riceve pagamenti in entrata associati a chiavi
pubbliche monouso che non possono essere collegate per un osservatore
esterno.

\subsubsection{Firme ad anello}\label{firme-ad-anello}

Un protocollo basato su firme ad anello monouso consente agli utenti di
ottenere un\textquotesingle anonimato incondizionato. Purtroppo, i tipi
ordinari di firme crittografiche permettono di tracciare le transazioni
ai rispettivi mittenti e destinatari. La \emph{one-time ring signature}
usa diverse tipi di firme, consiste di quattro algoritmi (\textbf{GEN,
SIG, VER, LNK}).

\begin{itemize}
  \item
    \textbf{GEN} prende parametri pubblici e restituisce una coppia ec
    \emph{$(P, x)$} e una chiave pubblica $I$.
  \item
    \textbf{SIG} riceve un messaggio $m$, un insieme $S'$ di chiavi pubbliche
    $\{P_i\}_{i \neq s}$, le coppie \emph{$(P_s, x_s)$} e restituisce una firma $\sigma$ e un
    insieme $S = S' \cup \{P_s\}$.
  \item
    \textbf{VER} riceve un messaggio $m$, un insieme $S$, una firma $\sigma$ e
    restituisce "true" o "false".
  \item
    \textbf{LNK} riceve un insieme $I = \{I_i\}$, una firma $\sigma$ e restituisce
    "linked" o "indep".
\end{itemize}

Lo scopo principale del protocollo è il seguente: un utente produce una
firma che può essere verificata non da una singola chiave pubblica, ma
da un insieme di chiavi. Il vero firmatario è indistinguibile dagli
altri proprietari di chiavi fino a quando non produce la seconda firma
sotto la stessa coppia di chiavi.

\begin{figure}[h]
  \centering
  \includegraphics[width = 0.55\textwidth]{image5.png}
\end{figure}

\begin{itemize}
  \item
    \textbf{GEN}: Il firmatario sceglie casualmente una chiave segreta $x \in
    [1,l-1]$ e calcola la chiave pubblica corrispondente $P=xG$. Inoltre,
    calcola un\textquotesingle altra chiave pubblica $I=xHp(P)$ chiamata
    "immagine della chiave".
  \item
    \textbf{SIG}: Il firmatario genera una firma ad anello one-time con
    una prova a conoscenza zero non interattiva. Seleziona un sottoinsieme
    casuale $S'$ di $n - 1$ chiavi pubbliche di altri utenti $P_i$,
    la propria coppia di chiavi $(x, P)$ e l\textquotesingle immagine della
    chiave $I$. Sia $1 \leq s \leq n$ l\textquotesingle indice segreto del firmatario in
    $S$ (in modo che la sua chiave sia $P_s$).\\
    Si sceglie casualmente un elemento casuale da $\{q_i | i = 1
    ... n\}$ e $\{w_i | i = 1 ... n, i \neq s\}$ da $(1 ... l)$ e effettua
    i seguenti passaggi:
    \[ L_i = \begin{cases} q_iG, & \text{se } i = s \\ q_iG+w_iP_i, & \text{se } i \neq s \end{cases} \]
\end{itemize}

\[ R_i = \begin{cases} q_iH_p(P_i), & \text{se } i = s \\ q_iH_p(P_{i})+ w_iI, & \text{se } i \neq s \end{cases} \]

Il prossimo passo è ottenere la sfida non interattiva:

\[ c = H_s(m, L_1, \ldots, L_n, R_1, \ldots, R_n) \]

Infine il firmatario calcola la risposta:

\[ c_i = \begin{cases} w_i, & \text{se } i \neq s \\ \left(c -\sum_{i=1}^{n} c_i\right) \mod l, & \text{se } i = s \end{cases} \]

\[ r_i = \begin{cases} q_i, & \text{se } i \neq s \\ q_s - c_sx \mod l ,& \text{se } i=s \end{cases} \]

La firma risultante è \[ \sigma= (I,c_1,\ldots,c_n,r_1,\ldots,r_n). \]:

\textbf{VER}: Chi sta verificando controlla la firma, ricostruendo:

\[ \begin{cases}
L_i' = r_iG + c_iP_i \\
R_i' = r_iH_p(P_i) + c_iI
\end{cases}
 \] Chi verifica controlla se
\[\sum_{i=1}^{n} ci =^? H_s(m,L_1',...,L_n',R_1',...R_n') \mod l \]

Se questa uguaglianza è vera, chi verifica esegue
l\textquotesingle algoritmo \textbf{LNK}, altrimenti respinge la firma.
- \textbf{LNK}: Chi verifica controlla se I è stata utilizzata in firme
passate (questi valori sono memorizzati nell\textquotesingle insieme I).
Un doppio utilizzo significa che sono state prodotte due firme con la
stessa chiave segreta.\\
Meccanismo del protocollo: utilizzando L-commitments, il firmatario
dimostra di conoscere un certo $x$ tale che almeno una $Pi = xG$.
Per rendere
questa prova non ripetibile introduciamo l\textquotesingle immagine
della chiave come $I=xHp(P)$. Il firmatario utilizza gli stessi
coefficienti $(r_i,c_i)$ per dimostrare quasi la stessa cosa: egli conosce
un certo $x$ tale che almeno uno $Hp(P_i)=I \cdot x^{-1}$. Se $x \rightarrow I$ è iniettiva:

\begin{verbatim}
- Nessuno può recuperare la chiave pubblica dall\'immagine della chiave
\end{verbatim}

e identificare il firmatario;

\begin{verbatim}
- Il firmatario non può fare due firme con I diverse e lo stesso x.
\end{verbatim}

Con una firma ad anello one-time, Bob può efficacemente nascondere
l'output di Alice (cioè, il suo input) tra gli altri: tutti i possibili
spenditori saranno equiprobabili, anche se Alice non ha più informazioni
di qualsiasi osservatore. Bob specifica n-1 outputs, non sapendo se
alcuni di questi sono stati spesi:\\
Un output può essere utilizzato in migliaia di firme come fattore di
ambiguità e mai come obiettivo di occultamento. Il controllo di doppia
spesa avviene nella fase LNK quando si cerca
nell\textquotesingle insieme delle immagini di chiave utilizzate.\\
Bob può scegliere il grado di ambiguità autonomamente: n = 2 significa
che avrà speso l\textquotesingle output con una probabilità del 50\%, n
= 100 dà il 1\%. La dimensione della firma risultante è lineare O(n),
quindi l\textquotesingle anonimato costa a Bob una dimensione di
transazione più grande e commissioni più alte.

Combinando entrambi i metodi (chiavi di transazione one-time e firme ad
anello one-time), Bob raggiunge un nuovo livello di privacy rispetto
allo schema originale di Bitcoin. Gli basta memorizzare una sola chiave
privata (a, b) e generare una chiave pubblica (A, B) per iniziare a
ricevere e inviare transazioni anonime. Per ogni output Bob recupera
coppie di chiavi di transazione uniche (pi, Pi) che non possono essere
collegate tra loro o alla sua chiave pubblica. Può spendere ognuna di
esse, firmando ogni input con una firma ad anello non tracciabile.

\subsection{Miglioramenti nella PoW rispetto a
Bitcoin}\label{miglioramenti-nella-pow-rispetto-a-bitcoin}

C'è stato anche un miglioramento dell'algoritmo di PoW, come obiettivo
primario vi è l'abbassamento del gap tra CPU e GPU/FPGA/ASIC.\\
Il protocollo originale di proof-of-work di Bitcoin utilizza la funzione
SHA-256.\\
Consiste principalmente di operatori logici di base e si basa
esclusivamente sulla velocità computazionale del processore, quindi è
perfettamente adatto per l\textquotesingle implementazione
multicore/conveyer. Tuttavia, i computer moderni non sono limitati solo
dal numero di operazioni al secondo, ma anche dalla dimensione della
memoria. Mentre alcuni processori possono essere notevolmente più veloci
di altri {[}9\^{}{]}, le dimensioni della memoria sono meno probabili
che varino tra le macchine.\\
L\textquotesingle idea principale è costruire un algoritmo che alloca un
ampio blocco di dati ("scratchpad") all\textquotesingle interno della
memoria e "accedere a una sequenza imprevedibile di posizioni" in esso.
Il blocco dovrebbe essere sufficientemente grande per rendere più
vantaggioso conservare i dati piuttosto che ricalcolarli ad ogni
accesso. L\textquotesingle algoritmo dovrebbe inoltre impedire il
parallelismo interno, quindi N thread simultanei dovrebbero richiedere N
volte più memoria contemporaneamente.\\
Dwork et al {[}16\^{}{]} hanno investigato e formalizzato questo
approccio, portandoli a suggerire un\textquotesingle altra variante
della funzione di pricing: "Mbound". Un altro lavoro appartiene a F.
Coelho {[}17\^{}{]}, che ha proposto la soluzione più efficace:
"Hokkaido". Con ogni probabilità, l\textquotesingle ultimo lavoro è
basato sull\textquotesingle idea di ricerche pseudo-casuali in un grande
array è l\textquotesingle algoritmo noto come "scrypt" di C. Percival
{[}18\^{}{]}. A differenza delle funzioni precedenti, si concentra sulla
derivazione delle chiavi e non sui sistemi di proof-of-work. Nonostante
ciò, scrypt funziona bene come funzione di prezzo nel problema di
conversione dell'hash parziale come SHA-256 in Bitcoin.\\
Per ora lo script è stato applicato a Litecoin {[}19\^{}{]}, ma la sua
implementazione non è veramente legata alla memoria: il rapporto ``tempo
di accesso alla memoria / tempo complessivo'' non è abbastanza grande
perché ogni istanza utilizza solo 128 KB, questo dunque permette ai
miner GPU di essere 10 volte più efficienti lasciando la possibilità di
creare dispositivi di mining efficienti e relativamente economici.\\
CryptoNote propone quindi un nuovo algoritmo memory-bound per la
proof-of-work. Si basa sull\textquotesingle accesso casuale a una
memoria lenta e sottolinea la dipendenza dalla latenza. A differenza di
scrypt, ogni nuovo blocco (lungo 64 byte) dipende da tutti i blocchi
precedenti e non solo da uno, quindi il compromesso tra dimensione della
memoria e velocità della CPU diventa esponenziale. Il nuovo algoritmo
richiede circa 2 Mb per istanza per i seguenti motivi:

\begin{itemize}
\item
  Si adatta alla cache L3 (per core) dei processori moderni, che
  diventeranno mainstream tra qualche anno;
\item
  Un megabyte di memoria interna è quasi una dimensione inaccettabile
  per il moderno pipeline ASIC;
\item
  Le GPU possono eseguire centinaia di istanze simultanee, ma sono
  limitate in altri modi: la memoria GDDR5 è più lenta della cache L3
  della CPU e notevole per la sua larghezza di banda, non per la
  velocità di accesso casuale.
\item
  Un\textquotesingle espansione significativa dello scratchpad
  richiederebbe un aumento delle iterazioni, il che implica a sua volta
  un aumento del tempo complessivo. Chiamate "pesanti" in una rete P2P
  senza fiducia possono portare a gravi vulnerabilità, perché i nodi
  sono obbligati a verificare il proof-of-work di ogni nuovo blocco. Se
  un nodo impiega una quantità considerevole di tempo per ogni
  valutazione dell\textquotesingle hash, può essere facilmente soggetto
  a attacchi DDoS da parte di una valanga di oggetti falsi con dati di
  lavoro arbitrari (valori di nonce).
\end{itemize}

\subsection{Equità nella
distibuzione}\label{equituxe0-nella-distibuzione}

Il limite superiore per l\textquotesingle ammontare complessivo delle
monete digitali CryptoNote è anche digitale:
\[\text{MSupply} = 2^{64} - 1\] unità atomiche. Questa è una restrizione
naturale basata solo su limiti di implementazione, non su intuizioni
come "N monete dovrebbero essere sufficienti per chiunque".

Per garantire la regolarità del processo di emissione, viene utilizzata
la seguente formula per le ricompense dei blocchi: \[
\text{BaseReward} = (\text{MSupply} - A) >> 18 \]

dove A è l\textquotesingle ammontare di monete generate precedentemente

CryptoNote contiene un algoritmo di targeting che cambia la difficoltà
di ogni blocco. Questo migliora il tempo di reazione del sistema quando
la potenza di calcolo della rete cresce o diminuisce intensamente,
preservando un tasso di blocco costante. Il metodo originale di Bitcoin
calcola il rapporto tra la difficoltà effettiva e quella target tra gli
ultimi 2016 blocchi e lo utilizza come moltiplicatore per la difficoltà
attuale. Ovviamente questo è inadatto per ricalcoli rapidi (a causa
dell\textquotesingle inerzia elevata) e porta a oscillazioni.
L\textquotesingle idea generale dietro l'algoritmo è sommare tutto il
lavoro completato dai nodi e dividerlo per il tempo impiegato per
completare il lavoro. La misura del lavoro sono i valori di difficoltà
corrispondenti in ogni blocco.

Gli utenti pagano gli altri per memorizzare la blockchain e dovrebbero
avere il diritto di votare per la sua dimensione. Ogni miner si
confronta con il compromesso tra bilanciare i costi e il profitto dalle
commissioni, quindi stabilisce il proprio "limite flessibile" per la
creazione dei blocchi. Inoltre, la regola fondamentale per la dimensione
massima del blocco è necessaria per evitare che la blockchain venga
inondatata da transazioni fasulle, tuttavia questo valore non dovrebbe
essere codificato duramente. Sia MN il valore mediano delle dimensioni
degli ultimi N blocchi.\\
Allora il "limite rigido" per la dimensione dei blocchi accettati è 2 ·
MN.

Un miner ha ancora la possibilità di riempire un blocco con le sue
transazioni senza commissioni fino alla dimensione massima di 2 MB.
Anche se solo la maggioranza dei miners può spostare il valore mediano,
esiste comunque la possibilità di gonfiare la blockchain e produrre un
carico aggiuntivo sui nodi. Per scoraggiare i partecipanti malevoli dal
creare blocchi grandi, introduciamo una funzione di penalità:

\[
\text{NewReward} = \text{BaseReward} \times \left( \frac{\text{DimBlocco}}{MN} - 1 \right)^2
\]

Questa regola viene applicata solo quando la DimBlocco è maggiore della
dimensione minima del blocco gratuito che dovrebbe essere vicina a \[
\max(10\, \text{kb}, M_N \cdot 110\%) \] I miners sono autorizzati a
creare blocchi di ``dimensioni usuali'' e persino a superarle con
profitto quando le commissioni complessive superano la penalità.\\
Tuttavia, è improbabile che le commissioni crescano in modo quadratico a
differenza del valore della penalità, quindi ci sarà un equilibrio.
